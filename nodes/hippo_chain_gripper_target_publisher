#!/usr/bin/env python

import rospy
from hippo_chain.msg import ChainState, ChainVehicleState
import numpy as np
import tf.transformations as tf
from dynamic_reconfigure.server import Server
from hippo_chain.cfg import GripperTargetConfig as Config
import threading
from geometry_msgs.msg import PoseStamped
from enum import Enum


class Mode(Enum):
    UNDEFINED = 0
    EXTEND = 1
    OBSERVE = 2
    INTERACT = 3


class Node():
    def __init__(self) -> None:
        rospy.init_node("setpoint_publisher")

        self.__mode = Mode.EXTEND
        self.__x = 1.0
        self.__y = 2.5
        self.__z = -1.0
        self.__yaw = 0.5*np.pi
        self.__pitch = 0.3*np.pi
        self.__roll = np.pi
        self.__offset = 0.19
        self.__data_lock = threading.RLock()
        self.__srv = Server(Config, self.__callback)
        self.__setpoint_pub = rospy.Publisher("/chain/target", ChainState, queue_size=1)
        self.__target_pose_pub = rospy.Publisher("/chain/target_pose", PoseStamped, queue_size=1)

    def __callback(self, config, level):
        with self.__data_lock:
            if config['update']:
                self.__mode = Mode(int(config['mode']))
                self.__x = config['x']
                self.__y = config['y']
                self.__z = config['z']
                self.__roll = np.pi/180 * config['roll']
                self.__pitch = np.pi/180 * config['pitch']
                self.__yaw = np.pi/180 * config['yaw']
                config['update'] = False
        return config

    def __getInteractionStateTarget(self):
        data = []

        R = tf.euler_matrix(self.__yaw, self.__pitch, self.__roll, "rzyx")
        [x, y, z] = np.array([self.__x, self.__y, self.__z]) - self.__offset * R[:3, 0]
        [qx, qy, qz, qw] = tf.quaternion_from_matrix(R)
        # [alpha, beta, trash] = tf.euler_from_matrix(np.transpose(R), "rzxz")

        base_vehicle = ChainVehicleState()
        base_vehicle.pose = [x, y, z, qw, qx, qy, qz]
        base_vehicle.twist = [0.0] * 6
        base_vehicle.accel = [0.0] * 6
        base_vehicle.accel = [0.0] * 6
        base_vehicle.vehicle_id = 0

        data.append(base_vehicle)

        child_vehicle_1 = ChainVehicleState()
        child_vehicle_1.vehicle_id = 1
        child_vehicle_1.pose = [-self.__roll, -self.__pitch, 0.0, 0.0, 0.0, 0.0, 0.0]
        child_vehicle_1.twist = [0.0] * 6
        child_vehicle_1.accel = [0.0] * 6
        
        data.append(child_vehicle_1)

        for i in range(2):
            child_vehicle_i = ChainVehicleState()
            child_vehicle_i.vehicle_id = 2+i
            child_vehicle_i.pose = [2*np.pi/3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
            child_vehicle_i.twist = [0.0] * 6
            child_vehicle_i.accel = [0.0] * 6
            
            data.append(child_vehicle_i)

        return data
    
    def __getObservationStateTarget(self):
        data = []

        base_vehicle = ChainVehicleState()
        k = 1.0/np.sqrt(2.0)
        kC = k*np.cos(0.5*self.__yaw)
        kS = k*np.sin(0.5*self.__yaw)
        base_vehicle.pose = [self.__x, self.__y, self.__z+self.__offset, kC, kS, -kC, kS]
        base_vehicle.twist = [0.0] * 6
        base_vehicle.accel = [0.0] * 6
        base_vehicle.vehicle_id = 0

        data.append(base_vehicle)

        child_vehicle_1 = ChainVehicleState()
        child_vehicle_1.vehicle_id = 1
        child_vehicle_1.pose = [0.0, np.pi/2, 0.0, 0.0, 0.0, 0.0, 0.0]
        child_vehicle_1.twist = [0.0] * 6
        child_vehicle_1.accel = [0.0] * 6
        
        data.append(child_vehicle_1)

        for i in range(2):
            child_vehicle_i = ChainVehicleState()
            child_vehicle_i.vehicle_id = 2+i
            child_vehicle_i.pose = [2*np.pi/3, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
            child_vehicle_i.twist = [0.0] * 6
            child_vehicle_i.accel = [0.0] * 6
            
            data.append(child_vehicle_i)

        return data

    def __getExtendedStateTarget(self):
        data = []

        base_vehicle = ChainVehicleState()
        base_vehicle.pose = [self.__x-self.__offset*np.cos(self.__yaw), self.__y-self.__offset*np.sin(self.__yaw), self.__z, np.cos(0.5*self.__yaw), 0.0, 0.0, np.sin(0.5*self.__yaw)]
        base_vehicle.twist = [0.0] * 6
        base_vehicle.accel = [0.0] * 6
        base_vehicle.vehicle_id = 0

        data.append(base_vehicle)

        child_vehicle_1 = ChainVehicleState()
        child_vehicle_1.vehicle_id = 1
        child_vehicle_1.pose = [0.0] * 7
        child_vehicle_1.twist = [0.0] * 6
        child_vehicle_1.accel = [0.0] * 6
        
        data.append(child_vehicle_1)

        for i in range(2):
            child_vehicle_i = ChainVehicleState()
            child_vehicle_i.vehicle_id = 2+i
            child_vehicle_i.pose = [0.0] * 7
            child_vehicle_i.twist = [0.0] * 6
            child_vehicle_i.accel = [0.0] * 6
            
            data.append(child_vehicle_i)

        return data

    def run(self):
        r = rospy.Rate(10.0)
        while not rospy.is_shutdown():
            msg = ChainState()
            if self.__mode == Mode.EXTEND:
                msg.data = self.__getExtendedStateTarget()
            elif self.__mode == Mode.OBSERVE:
                msg.data = self.__getObservationStateTarget()
            elif self.__mode == Mode.INTERACT:
                msg.data = self.__getInteractionStateTarget()
            else:
                rospy.logerr("Unknown mode selected!")
                continue
            msg.header.stamp = rospy.Time.now()
            self.__setpoint_pub.publish(msg)

            pose_msg = PoseStamped()
            pose_msg.header.stamp = rospy.Time.now()
            pose_msg.header.frame_id = "map"
            pose_msg.pose.position.x = self.__x
            pose_msg.pose.position.y = self.__y
            pose_msg.pose.position.z = self.__z
            pose_msg.pose.orientation.w = msg.data[0].pose[3]
            pose_msg.pose.orientation.x = msg.data[0].pose[4]
            pose_msg.pose.orientation.y = msg.data[0].pose[5]
            pose_msg.pose.orientation.z = msg.data[0].pose[6]
            self.__target_pose_pub.publish(pose_msg)

            r.sleep()


def main():
    n = Node()
    n.run()

if __name__ == "__main__":
    main()